import type { Flashcard } from "@/types/flashcard";

export const cs: Flashcard[] = [
  // 네트워크
  {
    id: 1,
    category: "CS",
    question: "네트워크에서 패킷이란 무엇을 의미하나요?",
    answer:
      "패킷은 네트워크를 통해 전송되는 데이터의 작은 단위입니다. 큰 데이터를 일정 크기로 분할하여 헤더(목적지, 출발지 등의 제어 정보)와 페이로드(실제 데이터)로 구성됩니다. 패킷 단위로 나누어 전송함으로써 네트워크 자원을 효율적으로 공유하고, 오류 발생 시 해당 패킷만 재전송할 수 있습니다.",
  },
  {
    id: 2,
    category: "CS",
    question: "네트워크에서 처리량은 무엇을 의미하나요?",
    answer:
      "처리량(Throughput)은 단위 시간당 네트워크를 통해 성공적으로 전달되는 데이터의 양을 의미합니다. 보통 bps(bits per second) 단위로 측정되며, 네트워크의 실질적인 성능을 나타내는 지표입니다. 대역폭, 네트워크 혼잡도, 패킷 손실률 등에 의해 영향을 받습니다.",
  },
  {
    id: 3,
    category: "CS",
    question: "지연시간이란 무엇인가요?",
    answer:
      "지연시간(Latency)은 데이터가 출발지에서 목적지까지 도달하는 데 걸리는 시간입니다. 전송 지연, 전파 지연, 처리 지연, 큐잉 지연 등으로 구성됩니다. 지연시간이 짧을수록 네트워크 응답이 빠르며, 실시간 서비스에서는 특히 중요한 성능 지표입니다.",
  },
  {
    id: 4,
    category: "CS",
    question: "처리량은 어떤 상황에 영향을 받나요?",
    answer:
      "처리량은 네트워크 대역폭, 네트워크 혼잡도, 패킷 손실률, 네트워크 토폴로지 등에 의해 영향을 받습니다. 특히 네트워크 경로상에서 가장 대역폭이 낮은 구간(병목 구간)이 전체 처리량을 제한합니다. 또한 많은 트래픽이 동시에 몰리면 혼잡이 발생하여 처리량이 감소할 수 있습니다.",
  },
  {
    id: 5,
    category: "CS",
    question: "네트워크 병목현상은 무엇인가요?",
    answer:
      "병목현상은 네트워크 경로 중 처리 능력이 가장 낮은 구간에서 전체 데이터 흐름이 제한되는 현상입니다. 마치 병의 좁은 목 부분처럼, 특정 구간의 대역폭이 낮거나 장비의 처리 능력이 부족하면 그 구간이 전체 네트워크 성능을 저하시킵니다. 병목 구간을 식별하고 해소하는 것이 네트워크 최적화의 핵심입니다.",
  },
  {
    id: 6,
    category: "CS",
    question:
      "TCP/IP가 무엇인가요? 각 계층에 대해서 설명할 수 있나요?",
    answer:
      "TCP/IP는 인터넷에서 데이터를 주고받기 위한 표준 프로토콜 모음입니다. 애플리케이션 계층(HTTP, FTP 등 사용자 서비스), 전송 계층(TCP/UDP로 데이터의 신뢰성 및 흐름 제어), 인터넷 계층(IP를 통한 주소 지정과 라우팅), 네트워크 인터페이스 계층(실제 물리적 데이터 전송)의 4개 계층으로 구성됩니다.",
  },
  {
    id: 7,
    category: "CS",
    question:
      "전송 계층의 대표적인 방식은 무엇이 있고 어떤 차이가 있나요? (TCP, UDP)",
    answer:
      "TCP는 연결 지향적 프로토콜로 3-way handshake를 통해 연결을 수립하고, 데이터의 순서 보장과 재전송을 통한 신뢰성을 제공합니다. UDP는 비연결 지향적 프로토콜로 연결 설정 없이 데이터를 전송하며, 신뢰성은 낮지만 속도가 빠릅니다. TCP는 웹 통신 등에, UDP는 실시간 스트리밍이나 게임 등에 주로 사용됩니다.",
  },
  {
    id: 8,
    category: "CS",
    question:
      "계층 간 데이터 송수신 과정에 대해 설명할 수 있나요? (캡슐화, 비캡슐화)",
    answer:
      "캡슐화는 상위 계층에서 하위 계층으로 데이터를 전달할 때, 각 계층에서 프로토콜 헤더를 추가하는 과정입니다. 비캡슐화(역캡슐화)는 수신 측에서 하위 계층부터 상위 계층으로 올라가며 각 계층의 헤더를 제거하여 원본 데이터를 복원하는 과정입니다. 이 과정을 통해 각 계층이 독립적으로 자신의 역할을 수행할 수 있습니다.",
  },
  {
    id: 9,
    category: "CS",
    question: "네트워크에서 PDU에 대해 알고 있나요?",
    answer:
      "PDU(Protocol Data Unit)는 각 네트워크 계층에서 처리하는 데이터의 단위입니다. 애플리케이션 계층에서는 메시지, 전송 계층에서는 세그먼트(TCP) 또는 데이터그램(UDP), 인터넷 계층에서는 패킷, 네트워크 인터페이스 계층에서는 프레임이라 부릅니다. 각 계층에서 헤더가 추가되면서 PDU의 명칭이 달라집니다.",
  },
  {
    id: 10,
    category: "CS",
    question: "로드밸런서란 무엇인가요?",
    answer:
      "로드밸런서는 들어오는 네트워크 트래픽을 여러 서버에 분산시켜주는 장치 또는 소프트웨어입니다. 라운드 로빈, 가중치 기반, 최소 연결 등 다양한 알고리즘을 사용하여 트래픽을 분배합니다. 이를 통해 서버의 과부하를 방지하고, 가용성과 안정성을 높일 수 있습니다.",
  },
  {
    id: 11,
    category: "CS",
    question: "ARP란 무엇인가요?",
    answer:
      "ARP(Address Resolution Protocol)는 IP 주소를 MAC 주소로 변환해주는 프로토콜입니다. 네트워크 통신 시 논리적 주소인 IP 주소만으로는 실제 물리적 전송이 불가능하므로, ARP를 통해 대상 장치의 MAC 주소를 알아내어 데이터 링크 계층에서의 통신을 가능하게 합니다.",
  },
  {
    id: 12,
    category: "CS",
    question: "MAC 주소란 무엇인가요?",
    answer:
      "MAC(Media Access Control) 주소는 네트워크 인터페이스 카드(NIC)에 할당된 고유한 물리적 주소입니다. 48비트로 구성되며 보통 16진수로 표기합니다(예: AA:BB:CC:DD:EE:FF). IP 주소와 달리 하드웨어에 고정된 주소로, 같은 네트워크(LAN) 내에서 장치를 식별하는 데 사용됩니다.",
  },
  {
    id: 13,
    category: "CS",
    question: "NAT란 무엇인가요?",
    answer:
      "NAT(Network Address Translation)는 사설 IP 주소를 공인 IP 주소로 변환하는 기술입니다. 하나의 공인 IP 주소를 여러 장치가 공유할 수 있게 해주어 IP 주소 부족 문제를 해결합니다. 또한 내부 네트워크 구조를 외부에 감춰 보안성을 높이는 효과도 있습니다.",
  },

  // HTTP
  {
    id: 14,
    category: "CS",
    question: "HTTP란 뭔가요?",
    answer:
      "HTTP(HyperText Transfer Protocol)는 웹에서 클라이언트와 서버 간에 데이터를 주고받기 위한 애플리케이션 계층 프로토콜입니다. 요청(Request)과 응답(Response) 구조로 동작하며, HTML 문서뿐만 아니라 이미지, 동영상, JSON 등 다양한 리소스를 전송할 수 있습니다.",
  },
  {
    id: 15,
    category: "CS",
    question: "HTTP 프로토콜의 가장 큰 특징은 뭔가요?",
    answer:
      "HTTP의 가장 큰 특징은 무상태(Stateless)와 비연결성(Connectionless)입니다. 무상태란 서버가 클라이언트의 이전 요청 상태를 기억하지 않는다는 것이고, 비연결성이란 요청에 대한 응답을 완료하면 연결을 끊는다는 의미입니다. 이러한 특성 덕분에 서버 자원을 효율적으로 사용할 수 있지만, 상태 유지가 필요한 경우 쿠키나 세션 등의 별도 메커니즘이 필요합니다.",
  },
  {
    id: 16,
    category: "CS",
    question: "URL은 뭔가요?",
    answer:
      "URL(Uniform Resource Locator)은 인터넷 상에서 리소스의 위치를 나타내는 주소입니다. 프로토콜(https://), 호스트(www.example.com), 포트(:443), 경로(/path), 쿼리 문자열(?key=value), 프래그먼트(#section) 등의 요소로 구성됩니다. 웹 브라우저는 URL을 해석하여 해당 서버에 리소스를 요청합니다.",
  },
  {
    id: 17,
    category: "CS",
    question: "HTTP/1.0과 HTTP/1.1의 차이는 뭔가요?",
    answer:
      "HTTP/1.0은 요청마다 새로운 TCP 연결을 생성하고 응답 후 즉시 연결을 종료합니다. HTTP/1.1은 지속 연결(Keep-Alive)을 기본으로 지원하여 하나의 TCP 연결에서 여러 요청과 응답을 주고받을 수 있습니다. 또한 HTTP/1.1은 파이프라이닝, Host 헤더 필수화, 청크 전송 인코딩 등의 기능을 추가로 지원합니다.",
  },
  {
    id: 18,
    category: "CS",
    question: "HTTP/1.1과 HTTP/2.0의 차이는 뭔가요?",
    answer:
      "HTTP/2.0은 멀티플렉싱을 도입하여 하나의 TCP 연결 위에서 여러 요청과 응답을 동시에 병렬 처리할 수 있습니다. 또한 헤더 압축(HPACK), 서버 푸시, 스트림 우선순위 등의 기능을 제공합니다. HTTP/1.1의 HOL(Head-of-Line) 블로킹 문제를 해결하여 웹 페이지 로딩 성능을 크게 개선했습니다.",
  },
  {
    id: 19,
    category: "CS",
    question: "HTTPS는 HTTP랑 뭐가 다른가요?",
    answer:
      "HTTPS는 HTTP에 SSL/TLS 암호화 계층을 추가한 프로토콜입니다. 데이터를 암호화하여 전송하므로 중간에서 도청이나 변조를 방지할 수 있습니다. 기본 포트가 HTTP는 80번, HTTPS는 443번이며, HTTPS는 인증서를 통해 서버의 신원을 보증합니다.",
  },
  {
    id: 20,
    category: "CS",
    question: "SSL/TLS란 무엇인가요?",
    answer:
      "SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)는 네트워크 통신의 보안을 제공하는 암호화 프로토콜입니다. SSL은 초기 버전이고 TLS는 SSL의 후속 표준으로, 현재는 TLS 1.2와 1.3이 주로 사용됩니다. 대칭키와 비대칭키 암호화를 조합하여 데이터의 기밀성, 무결성, 인증을 보장합니다.",
  },
  {
    id: 21,
    category: "CS",
    question: "HTTPS가 제공하는 세 가지 보안 특성은?",
    answer:
      "첫째, 기밀성(Confidentiality)으로 데이터를 암호화하여 도청을 방지합니다. 둘째, 무결성(Integrity)으로 데이터가 전송 중 변조되지 않았음을 보장합니다. 셋째, 인증(Authentication)으로 통신 상대방이 신뢰할 수 있는 서버인지 인증서를 통해 확인합니다.",
  },
  {
    id: 22,
    category: "CS",
    question: "비대칭키(공개키/개인키) 암호화란?",
    answer:
      "비대칭키 암호화는 공개키와 개인키라는 한 쌍의 키를 사용하는 암호화 방식입니다. 공개키로 암호화한 데이터는 개인키로만 복호화할 수 있고, 개인키로 서명한 데이터는 공개키로 검증할 수 있습니다. 대칭키보다 연산 속도가 느리지만, 키 교환 문제를 해결할 수 있어 초기 통신 설정에 주로 사용됩니다.",
  },
  {
    id: 23,
    category: "CS",
    question: "대칭키와 비대칭키의 혼합 사용이란?",
    answer:
      "실제 HTTPS 통신에서는 비대칭키 암호화로 안전하게 대칭키를 교환한 뒤, 이후의 실제 데이터 통신은 속도가 빠른 대칭키 암호화로 수행합니다. 비대칭키의 안전한 키 교환 장점과 대칭키의 빠른 암호화 속도 장점을 결합한 방식입니다. TLS 핸드셰이크 과정에서 이러한 혼합 사용이 이루어집니다.",
  },
  {
    id: 24,
    category: "CS",
    question: "TLS 핸드셰이크 과정을 설명해주세요",
    answer:
      "TLS 핸드셰이크는 클라이언트가 Client Hello(지원 암호화 방식 목록)를 보내고, 서버가 Server Hello(선택된 암호화 방식과 인증서)로 응답합니다. 클라이언트는 인증서를 검증하고 pre-master secret을 서버의 공개키로 암호화하여 전송합니다. 양쪽이 동일한 세션 키를 생성한 후 암호화된 통신을 시작하며, TLS 1.2 기준 2-RTT가 소요됩니다.",
  },
  {
    id: 25,
    category: "CS",
    question: "TLS 1.3 핸드셰이크 (1-RTT)란?",
    answer:
      "TLS 1.3은 핸드셰이크 과정을 1-RTT로 단축하여 연결 속도를 크게 개선했습니다. 클라이언트가 첫 메시지에서 키 공유 정보를 함께 보내기 때문에 서버가 즉시 키를 계산하고 암호화 통신을 시작할 수 있습니다. 또한 0-RTT 모드를 지원하여 이전에 연결한 적 있는 서버와는 첫 메시지부터 암호화된 데이터를 전송할 수도 있습니다.",
  },
  {
    id: 26,
    category: "CS",
    question: "TLS 1.2와 1.3의 차이점은?",
    answer:
      "TLS 1.3은 핸드셰이크를 2-RTT에서 1-RTT로 단축하고, 취약한 암호화 알고리즘(RSA 키 교환, RC4, SHA-1 등)을 제거했습니다. 또한 핸드셰이크 과정 자체도 암호화하여 보안을 강화했으며, 0-RTT 재연결을 지원합니다. 전체적으로 더 빠르고 안전한 통신을 제공합니다.",
  },
  {
    id: 27,
    category: "CS",
    question: "HTTPS 인증서 발급 과정에 대해 설명해주세요",
    answer:
      "서버 관리자가 공개키와 개인키 쌍을 생성하고, 공개키와 도메인 정보를 담은 CSR(인증서 서명 요청)을 CA(인증 기관)에 제출합니다. CA는 도메인 소유권 등을 검증한 뒤 자신의 개인키로 서명하여 SSL/TLS 인증서를 발급합니다. 서버는 이 인증서를 설치하여 클라이언트에게 자신의 신원을 증명합니다.",
  },

  // 운영체제
  {
    id: 28,
    category: "CS",
    question: "운영체제란 무엇인가요?",
    answer:
      "운영체제(OS)는 하드웨어 자원을 관리하고 사용자와 애플리케이션에 서비스를 제공하는 시스템 소프트웨어입니다. CPU, 메모리, 디스크, 입출력 장치 등의 자원을 효율적으로 관리하며, 프로세스 관리, 메모리 관리, 파일 시스템 관리 등의 핵심 기능을 수행합니다. Windows, macOS, Linux 등이 대표적인 운영체제입니다.",
  },
  {
    id: 29,
    category: "CS",
    question: "운영체제는 어떤 역할을 하나요?",
    answer:
      "운영체제는 프로세스 관리(CPU 스케줄링, 프로세스 생성/종료), 메모리 관리(가상 메모리, 페이징), 파일 시스템 관리(파일 읽기/쓰기, 디렉터리 관리), 입출력 관리(장치 드라이버)를 담당합니다. 또한 사용자 인터페이스를 제공하고, 보안 및 접근 제어 기능으로 시스템을 보호합니다.",
  },
  {
    id: 30,
    category: "CS",
    question: "운영체제는 어떤 구조로 이루어져 있나요?",
    answer:
      "운영체제는 크게 커널(Kernel)과 사용자 공간(User Space)으로 구성됩니다. 커널은 하드웨어와 직접 상호작용하며 프로세스, 메모리, 파일 시스템, 장치 드라이버를 관리하는 핵심 부분입니다. 사용자 공간에서는 애플리케이션이 실행되며, 시스템 콜을 통해 커널의 기능을 요청합니다.",
  },
  {
    id: 31,
    category: "CS",
    question: "컴퓨터는 어떤 요소로 이루어져 있나요?",
    answer:
      "컴퓨터는 CPU(중앙처리장치), 메모리(RAM), 보조 저장장치(HDD/SSD), 입출력 장치로 구성됩니다. CPU는 연산과 제어를 담당하고, 메모리는 실행 중인 프로그램과 데이터를 임시 저장합니다. 보조 저장장치는 데이터를 영구 저장하며, 이들은 시스템 버스(데이터, 주소, 제어 버스)를 통해 서로 통신합니다.",
  },
  {
    id: 32,
    category: "CS",
    question: "CPU는 어떤 요소로 이루어져 있나요?",
    answer:
      "CPU는 산술논리장치(ALU), 제어장치(CU), 레지스터로 구성됩니다. ALU는 덧셈, 뺄셈 등의 산술 연산과 AND, OR 등의 논리 연산을 수행합니다. 제어장치는 명령어를 해석하고 실행 순서를 제어하며, 레지스터는 CPU 내부의 초고속 임시 저장 공간으로 연산에 필요한 데이터와 명령어를 보관합니다.",
  },
  {
    id: 33,
    category: "CS",
    question: "CPU는 어떻게 동작하나요?",
    answer:
      "CPU는 명령어 사이클(Instruction Cycle)에 따라 동작합니다. 인출(Fetch) 단계에서 메모리에서 명령어를 가져오고, 해독(Decode) 단계에서 명령어를 분석하며, 실행(Execute) 단계에서 연산을 수행합니다. 이 과정을 반복하면서 프로그램을 처리하며, 현대 CPU는 파이프라이닝 등을 통해 여러 명령어를 동시에 처리하여 성능을 높입니다.",
  },
  {
    id: 34,
    category: "CS",
    question: "메모리란 무엇인가요?",
    answer:
      "메모리는 CPU가 직접 접근하여 데이터를 읽고 쓸 수 있는 기억 장치입니다. 보통 RAM(Random Access Memory)을 가리키며, 실행 중인 프로그램의 코드와 데이터를 임시로 저장합니다. 전원이 꺼지면 데이터가 사라지는 휘발성 메모리이며, 보조 저장장치보다 훨씬 빠른 속도로 데이터에 접근할 수 있습니다.",
  },
  {
    id: 35,
    category: "CS",
    question: "메모리는 어떤 계층 구조로 이루어져 있나요?",
    answer:
      "메모리는 속도와 용량의 트레이드오프에 따라 계층 구조를 이룹니다. 위에서부터 레지스터, L1/L2/L3 캐시, RAM(주기억장치), SSD/HDD(보조기억장치) 순으로, 위로 갈수록 속도가 빠르고 용량이 작으며 비용이 높습니다. 이 계층 구조를 통해 자주 사용되는 데이터를 빠르게 접근할 수 있도록 최적화합니다.",
  },
  {
    id: 36,
    category: "CS",
    question: "메모리는 어떤 방식으로 데이터를 관리하나요?",
    answer:
      "메모리는 가상 메모리, 페이징, 세그멘테이션 등의 방식으로 데이터를 관리합니다. 가상 메모리는 물리 메모리보다 큰 주소 공간을 프로세스에 제공하며, 페이징은 메모리를 고정 크기 페이지로 나누어 관리합니다. 운영체제는 스와핑을 통해 사용하지 않는 페이지를 디스크로 내보내고 필요할 때 다시 불러들입니다.",
  },

  // 프로세스와 스레드
  {
    id: 37,
    category: "CS",
    question: "프로세스가 뭔가요?",
    answer:
      "프로세스는 운영체제로부터 자원을 할당받아 실행 중인 프로그램의 인스턴스입니다. 각 프로세스는 독립적인 메모리 공간(코드, 데이터, 힙, 스택)을 할당받으며, 최소 하나의 스레드를 가집니다. 프로세스 간에는 메모리가 격리되어 있어 한 프로세스의 오류가 다른 프로세스에 직접 영향을 주지 않습니다.",
  },
  {
    id: 38,
    category: "CS",
    question: "스레드가 뭔가요?",
    answer:
      "스레드는 프로세스 내에서 실행되는 가장 작은 실행 단위입니다. 같은 프로세스의 스레드들은 코드, 데이터, 힙 영역을 공유하며, 각자 독립적인 스택과 레지스터 값을 가집니다. 스레드 간 메모리를 공유하기 때문에 프로세스 간 통신보다 빠르게 데이터를 교환할 수 있습니다.",
  },
  {
    id: 39,
    category: "CS",
    question: "프로세스와 스레드는 어떤 차이가 있나요?",
    answer:
      "프로세스는 독립적인 메모리 공간을 가지는 실행 단위이고, 스레드는 프로세스 내에서 메모리를 공유하는 실행 단위입니다. 프로세스 간 통신(IPC)은 파이프, 소켓 등 별도 메커니즘이 필요하지만, 스레드 간 통신은 공유 메모리로 빠르게 가능합니다. 대신 스레드는 공유 자원에 대한 동기화 처리가 필요하며, 하나의 스레드 오류가 전체 프로세스에 영향을 줄 수 있습니다.",
  },
  {
    id: 40,
    category: "CS",
    question: "프로세스의 컴파일 과정에 대해 설명해줄 수 있나요?",
    answer:
      "프로그램의 컴파일 과정은 전처리, 컴파일, 어셈블, 링킹 단계로 나뉩니다. 전처리 단계에서는 매크로 치환과 헤더 파일 포함 등을 처리하고, 컴파일 단계에서는 소스 코드를 어셈블리어로 변환합니다. 어셈블 단계에서 기계어 목적 파일로 변환하고, 링킹 단계에서 여러 목적 파일과 라이브러리를 결합하여 실행 가능한 파일을 생성합니다.",
  },
  {
    id: 41,
    category: "CS",
    question: "프로세스는 어떤 상태 값을 가지고 있나요?",
    answer:
      "프로세스는 생성(New), 준비(Ready), 실행(Running), 대기(Waiting/Blocked), 종료(Terminated) 상태를 가집니다. 생성된 프로세스는 준비 큐에 들어가고, CPU를 할당받으면 실행 상태가 됩니다. 입출력 요청 등이 발생하면 대기 상태로 전환되고, 작업이 완료되면 다시 준비 상태로 돌아갑니다.",
  },
  {
    id: 42,
    category: "CS",
    question:
      "프로세스는 어떤 구조로 이루어져 있나요? (스택, 힙, 데이터 영역, 코드 영역)",
    answer:
      "코드 영역에는 실행할 프로그램의 기계어 코드가 저장됩니다. 데이터 영역에는 전역 변수와 정적 변수가 저장됩니다. 힙 영역은 런타임에 동적으로 할당되는 메모리 공간(malloc, new 등)이며, 스택 영역은 함수 호출 시 지역 변수, 매개변수, 반환 주소가 저장됩니다. 힙은 낮은 주소에서 위로, 스택은 높은 주소에서 아래로 성장합니다.",
  },
  {
    id: 43,
    category: "CS",
    question: "PCB는 무엇인가요?",
    answer:
      "PCB(Process Control Block)는 운영체제가 각 프로세스를 관리하기 위해 유지하는 자료 구조입니다. 프로세스 ID, 프로세스 상태, 프로그램 카운터, CPU 레지스터 값, 메모리 관리 정보, 입출력 상태 정보 등을 포함합니다. 문맥 교환(Context Switch) 시 현재 프로세스의 상태를 PCB에 저장하고, 다음 프로세스의 PCB에서 상태를 복원하여 실행을 이어갑니다.",
  },

  // 싱글 스레드와 멀티 스레드
  {
    id: 44,
    category: "CS",
    question: "싱글 스레드의 장점은?",
    answer:
      "싱글 스레드는 하나의 실행 흐름만 존재하므로 동기화 문제(경쟁 상태, 교착 상태 등)가 발생하지 않아 구현이 단순합니다. 공유 자원에 대한 별도의 락 처리가 필요 없어 오버헤드가 적으며, 디버깅과 유지보수가 용이합니다. JavaScript의 이벤트 루프처럼 비동기 방식과 결합하면 높은 효율을 달성할 수 있습니다.",
  },
  {
    id: 45,
    category: "CS",
    question: "싱글 스레드의 단점은?",
    answer:
      "싱글 스레드는 CPU 코어를 하나만 활용하므로 멀티코어 프로세서의 성능을 충분히 활용하지 못합니다. 하나의 작업이 오래 걸리면 나머지 작업들이 모두 대기해야 하는 블로킹 문제가 발생할 수 있습니다. 또한 CPU 집약적인 작업을 수행할 경우 전체 애플리케이션의 응답성이 떨어질 수 있습니다.",
  },
  {
    id: 46,
    category: "CS",
    question: "멀티 스레드의 장점은?",
    answer:
      "멀티 스레드는 여러 CPU 코어를 동시에 활용하여 병렬 처리가 가능하므로 성능이 향상됩니다. 같은 프로세스 내에서 메모리를 공유하기 때문에 프로세스 간 통신보다 스레드 간 데이터 교환이 효율적입니다. 하나의 스레드가 대기 상태일 때 다른 스레드가 작업을 계속 수행하여 응답성을 높일 수 있습니다.",
  },
  {
    id: 47,
    category: "CS",
    question: "멀티 스레드의 단점은?",
    answer:
      "공유 자원에 대한 동시 접근으로 경쟁 상태(Race Condition)가 발생할 수 있어 동기화 처리가 필수적입니다. 동기화를 위한 락(Lock)은 교착 상태(Deadlock)를 유발할 수 있으며, 문맥 교환 비용이 추가로 발생합니다. 또한 디버깅이 어렵고, 재현하기 힘든 버그가 발생할 수 있어 개발 복잡도가 증가합니다.",
  },

  // 공유 자원 관련
  {
    id: 48,
    category: "CS",
    question: "공유 자원이란?",
    answer:
      "공유 자원은 여러 프로세스 또는 스레드가 동시에 접근할 수 있는 자원을 의미합니다. 전역 변수, 공유 메모리, 파일, 데이터베이스 등이 해당됩니다. 공유 자원에 대한 동시 접근을 적절히 제어하지 않으면 경쟁 상태가 발생하여 데이터 무결성이 깨질 수 있습니다.",
  },
  {
    id: 49,
    category: "CS",
    question: "임계 영역이란?",
    answer:
      "임계 영역(Critical Section)은 공유 자원에 접근하는 코드 영역으로, 동시에 하나의 프로세스(또는 스레드)만 실행할 수 있어야 하는 부분입니다. 상호 배제(Mutual Exclusion), 진행(Progress), 한정 대기(Bounded Waiting) 세 가지 조건을 만족해야 올바르게 동작합니다. 뮤텍스, 세마포어 등의 동기화 메커니즘으로 임계 영역을 보호합니다.",
  },
  {
    id: 50,
    category: "CS",
    question: "뮤텍스란?",
    answer:
      "뮤텍스(Mutex, Mutual Exclusion)는 공유 자원에 대해 하나의 스레드만 접근할 수 있도록 보장하는 잠금 메커니즘입니다. 스레드가 임계 영역에 진입할 때 락을 획득하고, 나올 때 락을 해제하는 방식으로 동작합니다. 락을 소유한 스레드만이 해제할 수 있다는 소유권 개념이 있어 세마포어와 구별됩니다.",
  },
  {
    id: 51,
    category: "CS",
    question: "세마포어란?",
    answer:
      "세마포어(Semaphore)는 정수 값을 이용하여 공유 자원에 접근할 수 있는 스레드의 수를 제어하는 동기화 도구입니다. 값이 1인 이진 세마포어는 뮤텍스와 유사하게 동작하고, 값이 N인 카운팅 세마포어는 N개의 스레드가 동시에 접근할 수 있습니다. P(wait) 연산으로 값을 감소시키고, V(signal) 연산으로 값을 증가시켜 동시 접근을 제어합니다.",
  },
  {
    id: 52,
    category: "CS",
    question: "교착 상태란?",
    answer:
      "교착 상태(Deadlock)는 둘 이상의 프로세스가 서로가 보유한 자원을 기다리며 무한히 대기하는 상태입니다. 상호 배제, 점유와 대기, 비선점, 순환 대기 네 가지 조건이 모두 만족될 때 발생합니다. 예방(조건 중 하나 제거), 회피(은행원 알고리즘 등), 탐지 및 복구 등의 방법으로 해결할 수 있습니다.",
  },

  // 쿠키 세션
  {
    id: 53,
    category: "CS",
    question: "쿠키, 세션을 왜 쓰나요?",
    answer:
      "HTTP는 무상태(Stateless) 프로토콜이기 때문에 서버가 클라이언트의 이전 요청 정보를 기억하지 못합니다. 로그인 상태 유지, 장바구니 정보, 사용자 설정 등 상태를 유지해야 하는 경우가 있어 쿠키와 세션을 사용합니다. 쿠키는 클라이언트 측에, 세션은 서버 측에 상태 정보를 저장하여 HTTP의 무상태 특성을 보완합니다.",
  },
  {
    id: 54,
    category: "CS",
    question: "쿠키가 뭔가요?",
    answer:
      "쿠키(Cookie)는 서버가 클라이언트(브라우저)에 저장하는 작은 텍스트 데이터입니다. 키-값 쌍으로 구성되며, 만료 시간, 도메인, 경로 등의 속성을 가집니다. 매 HTTP 요청 시 자동으로 서버에 전송되어 사용자 식별, 로그인 유지, 사용자 설정 저장 등에 활용됩니다.",
  },
  {
    id: 55,
    category: "CS",
    question: "세션이 뭔가요?",
    answer:
      "세션(Session)은 서버 측에서 클라이언트의 상태 정보를 저장하고 관리하는 방식입니다. 서버는 클라이언트에게 고유한 세션 ID를 발급하고, 이 ID를 쿠키에 담아 전달합니다. 이후 클라이언트가 세션 ID를 보내면 서버는 해당 ID로 저장된 상태 정보를 조회하여 사용자를 식별합니다.",
  },
  {
    id: 56,
    category: "CS",
    question: "쿠키와 세션의 차이는?",
    answer:
      "쿠키는 클라이언트(브라우저)에 데이터를 저장하고, 세션은 서버에 데이터를 저장합니다. 쿠키는 변조 위험이 있어 보안에 취약하지만, 세션은 서버에 저장되어 상대적으로 안전합니다. 쿠키는 만료 시간까지 유지되고, 세션은 보통 브라우저 종료 시 또는 설정된 시간이 지나면 삭제됩니다. 세션은 서버 자원을 사용하므로 사용자가 많으면 부하가 증가할 수 있습니다.",
  },
  {
    id: 57,
    category: "CS",
    question: "JWT를 아나요?",
    answer:
      "JWT(JSON Web Token)는 당사자 간에 정보를 JSON 형태로 안전하게 전송하기 위한 토큰 기반 인증 방식입니다. Header(알고리즘, 토큰 타입), Payload(클레임 데이터), Signature(서명) 세 부분으로 구성됩니다. 서버가 상태를 저장할 필요 없는 Stateless 인증이 가능하며, 서명을 통해 토큰의 무결성을 검증할 수 있습니다.",
  },
  {
    id: 58,
    category: "CS",
    question: "JWT를 웹 스토리지에 저장한다면 어디에 저장하겠나요?",
    answer:
      "일반적으로 localStorage보다는 httpOnly 쿠키에 저장하는 것이 XSS 공격에 안전합니다. localStorage에 저장하면 JavaScript로 접근 가능하여 XSS 공격에 취약하고, sessionStorage는 탭을 닫으면 사라져 사용성이 떨어집니다. httpOnly 쿠키를 사용하면 JavaScript에서 접근이 불가능하여 XSS를 방어할 수 있고, CSRF 공격은 SameSite 속성 등으로 별도 대응할 수 있습니다.",
  },

  // CORS
  {
    id: 59,
    category: "CS",
    question: "CORS가 뭔가요?",
    answer:
      "CORS(Cross-Origin Resource Sharing)는 브라우저가 다른 출처(Origin)의 서버에 요청을 보낼 수 있도록 허용하는 HTTP 헤더 기반 메커니즘입니다. 브라우저는 보안상 동일 출처 정책(SOP)을 적용하여 다른 출처의 리소스 접근을 제한합니다. 서버가 Access-Control-Allow-Origin 등의 응답 헤더를 설정하면 특정 출처에서의 요청을 허용할 수 있습니다.",
  },

  // 개발 방법론
  {
    id: 60,
    category: "CS",
    question: "소프트웨어 개발 주기(SDLC)에 대해 아나요?",
    answer:
      "SDLC(Software Development Life Cycle)는 소프트웨어를 체계적으로 개발하기 위한 전체 과정입니다. 요구사항 분석, 설계, 구현, 테스트, 배포, 유지보수의 단계로 구성됩니다. 폭포수, 애자일, V 모델, 나선형 모델 등 다양한 방법론이 있으며, 프로젝트 특성에 따라 적합한 방법론을 선택하여 적용합니다.",
  },
  {
    id: 61,
    category: "CS",
    question: "폭포수 방법론이란?",
    answer:
      "폭포수(Waterfall) 방법론은 소프트웨어 개발 단계를 순차적으로 진행하는 전통적인 개발 방법론입니다. 요구사항 분석 → 설계 → 구현 → 테스트 → 배포 → 유지보수 순서로 진행하며, 각 단계가 완료된 후 다음 단계로 넘어갑니다. 계획이 명확하고 요구사항 변경이 적은 프로젝트에 적합하지만, 유연성이 부족하고 후반에 문제를 발견하면 수정 비용이 큽니다.",
  },
  {
    id: 62,
    category: "CS",
    question: "애자일 방법론이란?",
    answer:
      "애자일(Agile) 방법론은 짧은 반복 주기(스프린트)를 통해 점진적으로 소프트웨어를 개발하는 방법론입니다. 변화하는 요구사항에 유연하게 대응하며, 고객과의 지속적인 소통과 피드백을 강조합니다. 스크럼(Scrum), 칸반(Kanban) 등의 구체적인 프레임워크가 있으며, 빠른 제품 출시와 반복적인 개선에 적합합니다.",
  },

  // 기타
  {
    id: 63,
    category: "CS",
    question: "캐시란 무엇인가요?",
    answer:
      "캐시(Cache)는 자주 사용하는 데이터를 빠르게 접근할 수 있는 임시 저장소에 보관하는 기술입니다. CPU 캐시, 브라우저 캐시, CDN 캐시, 서버 캐시 등 다양한 레벨에서 적용됩니다. 원본 데이터에 접근하는 비용(시간, 네트워크 요청 등)을 줄여 성능을 향상시키지만, 캐시된 데이터와 원본 데이터 간의 일관성 관리가 필요합니다.",
  },
  {
    id: 64,
    category: "CS",
    question: "CDN이란 뭔가요?",
    answer:
      "CDN(Content Delivery Network)은 전 세계 여러 지역에 분산된 서버 네트워크를 통해 사용자에게 콘텐츠를 빠르게 전달하는 시스템입니다. 사용자와 지리적으로 가까운 엣지 서버에서 캐시된 콘텐츠를 제공하여 지연시간을 줄입니다. 이미지, CSS, JavaScript 파일 등 정적 리소스 배포에 주로 사용되며, 원본 서버의 부하를 분산시키는 효과도 있습니다.",
  },

  // 테스트
  {
    id: 65,
    category: "CS",
    question: "테스트란 무엇인가요?",
    answer:
      "소프트웨어 테스트는 개발된 프로그램이 요구사항에 맞게 동작하는지 검증하고, 결함을 발견하여 품질을 보장하는 활동입니다. 코드의 정확성, 성능, 보안, 사용성 등 다양한 측면을 검증합니다. 개발 초기부터 테스트를 수행할수록 버그 수정 비용이 낮아지므로, 테스트는 개발 생명주기 전반에 걸쳐 중요합니다.",
  },
  {
    id: 66,
    category: "CS",
    question: "테스트의 예는 어떤 것들이 있나요?",
    answer:
      "유닛 테스트(개별 함수/컴포넌트 단위), 통합 테스트(모듈 간 상호작용), E2E 테스트(전체 사용자 시나리오), 성능 테스트(부하, 스트레스), 보안 테스트(취약점 검증) 등이 있습니다. 또한 회귀 테스트(변경 후 기존 기능 확인), A/B 테스트(두 버전 비교), 수용 테스트(사용자 관점 요구사항 충족 확인) 등도 있습니다.",
  },
  {
    id: 67,
    category: "CS",
    question: "테스트는 왜 해야 하나요?",
    answer:
      "테스트를 통해 버그를 사전에 발견하고 수정하여 소프트웨어의 안정성과 품질을 보장할 수 있습니다. 코드 변경 시 기존 기능이 깨지지 않았는지 빠르게 확인하여 리팩토링과 유지보수를 안전하게 할 수 있습니다. 또한 테스트 코드가 곧 개발 문서 역할을 하여 코드의 의도와 동작을 명확히 전달합니다.",
  },
  {
    id: 68,
    category: "CS",
    question: "유닛 테스트란?",
    answer:
      "유닛 테스트(Unit Test)는 함수, 메서드, 컴포넌트 등 가장 작은 단위의 코드를 독립적으로 검증하는 테스트입니다. 외부 의존성은 모킹(Mocking)하여 격리된 환경에서 수행하며, 빠르게 실행되어 개발 중 즉각적인 피드백을 받을 수 있습니다. Jest, Vitest, JUnit 등의 프레임워크를 사용합니다.",
  },
  {
    id: 69,
    category: "CS",
    question: "통합 테스트란?",
    answer:
      "통합 테스트(Integration Test)는 여러 모듈이나 컴포넌트가 함께 동작할 때 상호작용이 올바르게 이루어지는지 검증하는 테스트입니다. API 호출과 응답, 데이터베이스 연동, 여러 컴포넌트 간의 데이터 흐름 등을 테스트합니다. 유닛 테스트에서 발견하기 어려운 모듈 간 인터페이스 문제를 발견할 수 있습니다.",
  },
  {
    id: 70,
    category: "CS",
    question: "E2E 테스트란?",
    answer:
      "E2E(End-to-End) 테스트는 실제 사용자의 관점에서 애플리케이션의 전체 동작 흐름을 검증하는 테스트입니다. 브라우저를 자동화하여 로그인, 폼 입력, 페이지 이동 등 실제 사용 시나리오를 시뮬레이션합니다. Cypress, Playwright 등의 도구를 사용하며, 유닛/통합 테스트보다 실행 시간이 길지만 사용자 경험 수준의 검증이 가능합니다.",
  },

  // 웹팩
  {
    id: 71,
    category: "CS",
    question: "웹팩이란?",
    answer:
      "웹팩(Webpack)은 JavaScript 애플리케이션을 위한 정적 모듈 번들러입니다. 의존 관계가 있는 다양한 모듈(JS, CSS, 이미지 등)을 분석하여 하나 또는 여러 개의 번들 파일로 합쳐줍니다. 로더(Loader)를 통해 다양한 파일 형식을 처리하고, 플러그인(Plugin)으로 번들링 과정을 확장할 수 있습니다.",
  },
  {
    id: 72,
    category: "CS",
    question: "모듈이란?",
    answer:
      "모듈은 독립적인 기능을 가진 코드의 단위로, 재사용 가능하도록 분리된 파일이나 코드 블록입니다. JavaScript에서는 ES Modules(import/export), CommonJS(require/module.exports) 등의 모듈 시스템을 사용합니다. 모듈화를 통해 코드의 유지보수성, 재사용성, 가독성을 높이고 이름 충돌을 방지할 수 있습니다.",
  },
  {
    id: 73,
    category: "CS",
    question: "모듈 번들링이란?",
    answer:
      "모듈 번들링은 여러 개의 모듈 파일과 의존성을 분석하여 하나 또는 최적화된 소수의 파일로 합치는 과정입니다. 브라우저가 수많은 개별 파일을 요청하는 대신 번들된 파일만 로드하면 되어 네트워크 요청 수를 줄이고 로딩 속도를 개선합니다. 코드 스플리팅, 트리 셰이킹 등의 최적화 기법도 함께 적용됩니다.",
  },
  {
    id: 74,
    category: "CS",
    question: "웹팩이 등장한 이유와 사용 시 이점은?",
    answer:
      "웹 애플리케이션이 복잡해지면서 수많은 JavaScript 파일과 의존성을 효율적으로 관리할 필요성이 생겼고, 이를 해결하기 위해 웹팩이 등장했습니다. 모듈 의존성을 자동으로 관리하고, 코드 스플리팅으로 초기 로딩 속도를 개선하며, 트리 셰이킹으로 사용하지 않는 코드를 제거합니다. 또한 개발 서버와 HMR(Hot Module Replacement)을 제공하여 개발 생산성을 높여줍니다.",
  },
  {
    id: 75,
    category: "CS",
    question: "바벨이란?",
    answer:
      "바벨(Babel)은 최신 JavaScript 문법(ES6+)을 구형 브라우저에서도 동작할 수 있는 이전 버전의 JavaScript로 변환해주는 트랜스파일러입니다. 화살표 함수, 클래스, 템플릿 리터럴, async/await 등의 최신 문법을 ES5 코드로 변환합니다. 또한 JSX 변환, 타입스크립트 변환 등의 기능도 플러그인을 통해 제공합니다.",
  },
  {
    id: 76,
    category: "CS",
    question: "웹팩의 주요 속성 4가지는?",
    answer:
      "Entry는 번들링의 시작점이 되는 파일을 지정합니다. Output은 번들 결과물의 파일명과 경로를 설정합니다. Loader는 JavaScript 이외의 파일(CSS, 이미지 등)을 모듈로 변환하는 역할을 합니다. Plugin은 번들링 과정 전체에 걸쳐 다양한 기능(번들 최적화, 환경변수 주입, HTML 생성 등)을 수행합니다.",
  },

  // 타입과 인터페이스
  {
    id: 77,
    category: "CS",
    question: "타입스크립트를 왜 쓰나요?",
    answer:
      "타입스크립트는 정적 타입 시스템을 통해 컴파일 시점에 타입 오류를 발견하여 런타임 에러를 줄여줍니다. IDE에서 자동 완성, 타입 추론, 리팩토링 지원 등 강력한 개발 도구 지원을 받을 수 있어 생산성이 향상됩니다. 또한 타입이 곧 문서 역할을 하여 코드의 의도를 명확히 전달하고, 대규모 프로젝트에서의 협업과 유지보수를 용이하게 합니다.",
  },
  {
    id: 78,
    category: "CS",
    question: "타입과 인터페이스의 차이를 아나요?",
    answer:
      "type은 유니온 타입, 인터섹션 타입, 튜플, 기본 타입 별칭 등 다양한 타입 조합을 표현할 수 있습니다. interface는 객체의 구조를 정의하는 데 특화되어 있으며, 선언 병합(Declaration Merging)이 가능합니다. interface는 extends로 확장하고, type은 & 연산자로 결합합니다. 일반적으로 객체 타입은 interface, 유니온이나 복합 타입은 type을 사용합니다.",
  },
  {
    id: 79,
    category: "CS",
    question:
      "유틸리티 타입 중 알고 있는 것들에 대해 설명해주세요",
    answer:
      "Partial<T>는 모든 속성을 선택적으로 만들고, Required<T>는 모든 속성을 필수로 만듭니다. Pick<T, K>는 특정 속성만 선택하고, Omit<T, K>는 특정 속성을 제외합니다. Readonly<T>는 모든 속성을 읽기 전용으로, Record<K, V>는 키-값 타입을 정의합니다. ReturnType<T>는 함수의 반환 타입을 추출합니다.",
  },
  {
    id: 80,
    category: "CS",
    question:
      "어떤 상황에서 타입을 쓰고 어떤 상황에서 인터페이스를 쓰나요?",
    answer:
      "interface는 객체의 구조를 정의하거나, 클래스가 구현할 계약을 명시하거나, 선언 병합이 필요한 라이브러리 타입 확장 시에 사용합니다. type은 유니온 타입(A | B), 인터섹션 타입(A & B), 튜플, 기본 타입 별칭, 매핑된 타입 등 복합적인 타입 표현이 필요할 때 사용합니다. 팀 컨벤션에 따라 통일하는 것이 좋으며, 일반적으로 객체 구조 정의에는 interface, 그 외에는 type을 권장합니다.",
  },
];
