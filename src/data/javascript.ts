import type { Flashcard } from "@/types/flashcard";

export const javascript: Flashcard[] = [
  {
    id: 201,
    category: "JavaScript",
    question: "프로그래밍이란 뭐라고 생각하나요?",
    answer:
      "프로그래밍이란 컴퓨터에게 특정 작업을 수행하도록 명령어를 작성하는 과정입니다. 사람의 의도를 프로그래밍 언어라는 도구를 통해 컴퓨터가 이해할 수 있는 형태로 변환하여 문제를 해결하는 행위를 말합니다.",
  },
  {
    id: 202,
    category: "JavaScript",
    question: "컴파일러는 뭐고 인터프리터는 뭔가요?",
    answer:
      "컴파일러는 소스 코드 전체를 한꺼번에 기계어로 번역한 후 실행하는 방식이고, 인터프리터는 소스 코드를 한 줄씩 읽어가며 즉시 실행하는 방식입니다. 컴파일러는 실행 속도가 빠르지만 번역 시간이 필요하고, 인터프리터는 즉시 실행 가능하지만 실행 속도가 상대적으로 느립니다. 자바스크립트는 기본적으로 인터프리터 언어이지만, V8 같은 현대 엔진은 JIT 컴파일을 사용하여 성능을 최적화합니다.",
  },
  {
    id: 203,
    category: "JavaScript",
    question: "자바스크립트의 특징은 뭐가 있나요?",
    answer:
      "자바스크립트는 웹 브라우저에서 동작하는 인터프리터 기반의 프로그래밍 언어로, 동적 타이핑을 지원합니다. 프로토타입 기반 객체지향을 지원하며, 일급 함수를 가진 멀티 패러다임 언어입니다. 또한 싱글 스레드로 동작하지만 이벤트 루프를 통해 비동기 처리를 효율적으로 수행할 수 있습니다.",
  },
  {
    id: 204,
    category: "JavaScript",
    question: "변수란 무엇인가요?",
    answer:
      "변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 또는 그 메모리 공간을 식별하기 위해 붙인 이름입니다. 프로그래밍에서 값을 저장하고 참조하기 위한 메커니즘으로, 값의 위치를 가리키는 상징적인 이름이라고 할 수 있습니다.",
  },
  {
    id: 205,
    category: "JavaScript",
    question: "식별자란 무엇인가요?",
    answer:
      "식별자는 변수, 함수, 클래스 등 어떤 값을 구별하여 식별할 수 있는 고유한 이름을 말합니다. 식별자는 값이 아닌 메모리 주소를 기억하고 있으며, 이를 통해 메모리에 저장된 값에 접근할 수 있습니다. 선언에 의해 자바스크립트 엔진에 식별자의 존재를 알립니다.",
  },
  {
    id: 206,
    category: "JavaScript",
    question: "변수를 선언한다는 것은 어떤 것을 의미하나요?",
    answer:
      "변수를 선언한다는 것은 값을 저장하기 위한 메모리 공간을 확보하고, 변수 이름과 해당 메모리 주소를 연결하여 값을 저장할 수 있게 준비하는 것을 의미합니다. 자바스크립트에서 변수 선언은 선언 단계(변수 이름 등록)와 초기화 단계(메모리 공간 확보 후 undefined 할당)를 거칩니다.",
  },
  {
    id: 207,
    category: "JavaScript",
    question: "var 키워드는 뭔가요?",
    answer:
      "var는 자바스크립트에서 변수를 선언할 때 사용하는 키워드로, ES6 이전에 유일한 변수 선언 방법이었습니다. var로 선언한 변수는 함수 레벨 스코프를 가지며, 선언과 초기화가 동시에 이루어져 호이스팅 시 undefined로 초기화됩니다. 또한 중복 선언이 허용되고, 선언 전에도 참조가 가능하다는 특징이 있습니다.",
  },
  {
    id: 208,
    category: "JavaScript",
    question: "호이스팅이 뭔가요?",
    answer:
      "호이스팅은 자바스크립트 엔진이 코드 실행 전 변수와 함수 선언을 해당 스코프의 최상단으로 끌어올리는 것처럼 동작하는 특성입니다. var는 선언과 초기화가 함께 호이스팅되어 undefined로 접근 가능하지만, let과 const는 선언만 호이스팅되어 TDZ(Temporal Dead Zone)에 의해 초기화 전 접근 시 에러가 발생합니다. 함수 선언문은 전체가 호이스팅되어 선언 전에 호출이 가능합니다.",
  },
  {
    id: 209,
    category: "JavaScript",
    question: "var 키워드의 문제점은 무엇이 있나요?",
    answer:
      "var는 함수 레벨 스코프만 지원하여 블록 내에서 선언해도 블록 외부에서 접근이 가능합니다. 중복 선언이 허용되어 의도치 않게 변수값이 변경될 수 있고, 호이스팅으로 인해 선언 전에 참조해도 에러가 발생하지 않아 예측하기 어려운 코드가 됩니다. 이러한 문제들 때문에 ES6에서 let과 const가 도입되었습니다.",
  },
  {
    id: 210,
    category: "JavaScript",
    question: "let 키워드는 var 키워드와 어떤 점이 다른가요?",
    answer:
      "let은 블록 레벨 스코프를 가져 if문이나 for문 등의 블록 내에서 선언한 변수는 블록 외부에서 접근할 수 없습니다. 중복 선언이 불가능하여 같은 스코프에서 같은 이름으로 다시 선언하면 SyntaxError가 발생합니다. 또한 호이스팅은 되지만 TDZ가 존재하여 선언 전에 접근하면 ReferenceError가 발생합니다.",
  },
  {
    id: 211,
    category: "JavaScript",
    question: "TDZ란?",
    answer:
      "TDZ(Temporal Dead Zone, 일시적 사각지대)는 let이나 const로 선언한 변수가 스코프 시작 지점부터 초기화 시작 지점까지 참조할 수 없는 구간을 말합니다. 이 구간에서 변수에 접근하면 ReferenceError가 발생합니다. TDZ는 변수가 선언되기 전에 사용되는 것을 방지하여 코드의 예측 가능성과 안정성을 높여줍니다.",
  },
  {
    id: 212,
    category: "JavaScript",
    question: "const 키워드는 어떤 특징이 있나요?",
    answer:
      "const는 반드시 선언과 동시에 초기화해야 하며, 재할당이 불가능한 상수를 선언할 때 사용합니다. let과 마찬가지로 블록 레벨 스코프를 가지며 중복 선언이 불가능합니다. 다만 const로 선언한 객체나 배열의 경우, 참조값 자체는 변경할 수 없지만 객체의 프로퍼티나 배열의 요소는 변경할 수 있습니다.",
  },
  {
    id: 213,
    category: "JavaScript",
    question: "리터럴이 뭔가요?",
    answer:
      "리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법입니다. 예를 들어 숫자 리터럴 100, 문자열 리터럴 'hello', 객체 리터럴 {}, 배열 리터럴 [] 등이 있습니다. 자바스크립트 엔진은 런타임에 리터럴을 평가하여 값을 생성합니다.",
  },
  {
    id: 214,
    category: "JavaScript",
    question: "데이터 타입의 종류는 어떤 것들이 있나요?",
    answer:
      "자바스크립트의 데이터 타입은 원시 타입과 객체 타입으로 나뉩니다. 원시 타입에는 number, string, boolean, undefined, null, symbol, bigint 7가지가 있습니다. 객체 타입에는 객체, 배열, 함수 등이 포함되며, 원시 타입을 제외한 모든 값은 객체 타입입니다.",
  },
  {
    id: 215,
    category: "JavaScript",
    question: "데이터 타입은 왜 필요할까요?",
    answer:
      "데이터 타입은 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해 필요합니다. 또한 메모리에서 값을 읽을 때 한 번에 읽어야 할 메모리 공간의 크기를 알기 위해, 그리고 읽어온 2진수를 어떻게 해석할지 결정하기 위해 필요합니다.",
  },
  {
    id: 216,
    category: "JavaScript",
    question: "정적 타이핑이 뭔가요?",
    answer:
      "정적 타이핑은 변수를 선언할 때 데이터 타입을 명시적으로 지정하는 방식입니다. 컴파일 시점에 타입이 결정되며, 선언한 타입과 다른 값을 할당하면 컴파일 에러가 발생합니다. C, Java, TypeScript 등이 정적 타이핑 언어에 해당하며, 런타임 전에 타입 관련 오류를 잡을 수 있어 안정성이 높습니다.",
  },
  {
    id: 217,
    category: "JavaScript",
    question: "동적 타이핑이 뭔가요?",
    answer:
      "동적 타이핑은 변수 선언 시 타입을 지정하지 않고, 할당된 값에 의해 런타임에 타입이 자동으로 결정되는 방식입니다. 자바스크립트는 대표적인 동적 타이핑 언어로, 같은 변수에 다른 타입의 값을 자유롭게 재할당할 수 있습니다. 유연하지만 타입 관련 버그가 발생하기 쉬워 주의가 필요합니다.",
  },
  {
    id: 218,
    category: "JavaScript",
    question: "truthy / falsy 한 값이 뭔가요?",
    answer:
      "falsy 값은 불리언으로 평가될 때 false로 취급되는 값으로, false, 0, -0, 0n, '', null, undefined, NaN이 있습니다. truthy 값은 falsy가 아닌 모든 값으로, 빈 배열 [], 빈 객체 {}, 문자열 '0' 등도 truthy입니다. 조건문이나 논리 연산에서 암묵적 타입 변환이 일어날 때 이 개념이 중요하게 사용됩니다.",
  },
  {
    id: 219,
    category: "JavaScript",
    question: "자바스크립트의 배열은 자료구조의 배열과 같나요?",
    answer:
      "자바스크립트의 배열은 일반적인 자료구조의 밀집 배열(dense array)과 다릅니다. 자료구조의 배열은 동일한 크기의 메모리 공간이 연속적으로 나열되지만, 자바스크립트의 배열은 각 요소의 메모리 크기가 다를 수 있고 연속적이지 않은 희소 배열(sparse array)입니다. 자바스크립트의 배열은 사실 인덱스를 프로퍼티 키로 가지는 특수한 객체이며, 해시 테이블로 구현되어 인덱스 접근은 느리지만 삽입/삭제는 빠릅니다.",
  },
  {
    id: 220,
    category: "JavaScript",
    question: "배열의 메서드는 어떤 종류가 있나요?",
    answer:
      "배열 메서드는 원본 배열을 변경하는 뮤테이터 메서드와 새로운 배열을 반환하는 접근자 메서드로 나뉩니다. 뮤테이터 메서드에는 push, pop, shift, unshift, splice, sort, reverse 등이 있고, 접근자 메서드에는 slice, concat, join, indexOf, includes 등이 있습니다. 또한 forEach, map, filter, reduce, find, some, every 같은 고차 함수 메서드가 있어 배열을 함수형으로 처리할 수 있습니다.",
  },
  {
    id: 221,
    category: "JavaScript",
    question: "고차 함수에 대해서 아나요?",
    answer:
      "고차 함수는 함수를 인수로 전달받거나 함수를 반환하는 함수를 말합니다. 자바스크립트의 함수는 일급 객체이므로 값처럼 전달하고 반환할 수 있어 고차 함수를 만들 수 있습니다. 대표적으로 배열의 map, filter, reduce 등이 고차 함수이며, 이를 통해 외부 상태를 변경하지 않는 선언적 프로그래밍이 가능합니다.",
  },
  {
    id: 222,
    category: "JavaScript",
    question: "forEach 메서드와 map메서드의 차이점에 대해 알고 있나요?",
    answer:
      "forEach는 배열의 각 요소에 대해 콜백 함수를 실행하지만 반환값이 undefined이고, map은 콜백 함수의 반환값으로 구성된 새로운 배열을 반환합니다. forEach는 단순히 반복하며 부수 효과를 수행할 때 사용하고, map은 원본 배열을 변환하여 새 배열을 만들 때 사용합니다. 원본 배열을 변경하지 않는다는 점은 두 메서드 모두 동일합니다.",
  },
  {
    id: 223,
    category: "JavaScript",
    question: "자바스크립트에서 객체란 뭘까요?",
    answer:
      "자바스크립트에서 객체는 키(key)와 값(value)으로 구성된 프로퍼티의 집합입니다. 원시 타입을 제외한 함수, 배열, 정규표현식 등 거의 모든 것이 객체입니다. 객체는 프로퍼티를 통해 상태(state)를, 메서드를 통해 동작(behavior)을 하나로 묶어 표현할 수 있는 자료구조입니다.",
  },
  {
    id: 224,
    category: "JavaScript",
    question: "함수와 메서드의 차이점에 대해 알고 계신가요?",
    answer:
      "함수는 독립적으로 정의되어 호출할 수 있는 코드 블록이고, 메서드는 객체의 프로퍼티로 할당된 함수를 말합니다. 메서드는 자신이 속한 객체를 this로 참조할 수 있지만, 일반 함수의 this는 전역 객체(또는 strict 모드에서 undefined)를 가리킵니다. ES6의 메서드 축약 표현으로 정의된 메서드는 내부 슬롯 [[HomeObject]]를 가지며, super 키워드를 사용할 수 있습니다.",
  },
  {
    id: 225,
    category: "JavaScript",
    question: "자바스크립트에서 객체를 생성하는 방법은 어떤 것들이 있나요?",
    answer:
      "객체 리터럴({})을 사용하는 방법이 가장 일반적이며, Object 생성자 함수(new Object()), 생성자 함수, Object.create() 메서드, 그리고 ES6의 클래스(class)를 사용하는 방법이 있습니다. 객체 리터럴은 간편하지만 동일한 구조의 객체를 여러 개 만들 때는 비효율적이며, 이런 경우 생성자 함수나 클래스를 사용하는 것이 적합합니다.",
  },
  {
    id: 226,
    category: "JavaScript",
    question: "객체 프로퍼티 접근 시 메모리 동작은 어떻게 되나요?",
    answer:
      "객체에 프로퍼티로 접근하면, 자바스크립트 엔진은 먼저 해당 객체의 메모리 주소를 찾고 그 안에서 프로퍼티 키를 검색합니다. 프로퍼티 값이 원시 타입이면 해당 값이 직접 저장되어 있고, 참조 타입이면 또 다른 메모리 주소를 참조합니다. V8 같은 엔진은 히든 클래스(Hidden Class)와 인라인 캐싱 등의 최적화 기법으로 프로퍼티 접근 성능을 향상시킵니다.",
  },
  {
    id: 227,
    category: "JavaScript",
    question: "전역 객체에 대해서 아나요?",
    answer:
      "전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 가장 먼저 생성되는 특수한 객체입니다. 브라우저 환경에서는 window, Node.js 환경에서는 global이며, ES11부터는 globalThis로 통일하여 접근할 수 있습니다. 전역 객체는 표준 빌트인 객체, 호스트 객체, var로 선언한 전역 변수와 전역 함수를 프로퍼티로 가집니다.",
  },
  {
    id: 228,
    category: "JavaScript",
    question: "값에 의한 전달이 뭔가요?",
    answer:
      "값에 의한 전달은 원시 타입의 값을 다른 변수에 할당할 때 원본 값이 복사되어 전달되는 방식입니다. 복사된 값은 원본과 독립적인 메모리 공간에 저장되므로, 한쪽 값을 변경해도 다른 쪽에 영향을 주지 않습니다. 원시 값의 불변성(immutability)을 보장하는 기본 동작 방식입니다.",
  },
  {
    id: 229,
    category: "JavaScript",
    question: "참조에 의한 전달이 뭔가요?",
    answer:
      "참조에 의한 전달은 객체를 변수에 할당할 때 메모리 주소(참조값)가 복사되어 전달되는 방식입니다. 두 변수가 같은 객체를 가리키므로, 한쪽에서 객체를 수정하면 다른 변수를 통해서도 변경된 내용이 반영됩니다. 이로 인해 의도치 않은 부수 효과가 발생할 수 있어, 불변 객체를 만들거나 깊은 복사를 활용하는 것이 중요합니다.",
  },
  {
    id: 230,
    category: "JavaScript",
    question: "함수 선언문과 함수 표현식은 어떤 차이가 있나요?",
    answer:
      "함수 선언문은 function 키워드로 함수를 정의하며 함수 이름을 생략할 수 없고, 함수 표현식은 변수에 함수를 할당하는 방식입니다. 가장 큰 차이는 호이스팅 동작으로, 함수 선언문은 전체가 호이스팅되어 선언 전에 호출이 가능하지만, 함수 표현식은 변수 호이스팅만 발생하여 선언 전에 호출하면 에러가 발생합니다.",
  },
  {
    id: 231,
    category: "JavaScript",
    question: "즉시 실행 함수(IIFE)에 대해 알고 있나요?",
    answer:
      "즉시 실행 함수(IIFE, Immediately Invoked Function Expression)는 정의와 동시에 즉시 호출되는 함수입니다. (function() { ... })() 형태로 작성하며, 한 번만 실행되고 다시 호출할 수 없습니다. 주로 전역 스코프를 오염시키지 않기 위해 독립적인 스코프를 만들 때 사용하며, 모듈 패턴 등에서 활용됩니다.",
  },
  {
    id: 232,
    category: "JavaScript",
    question: "스코프가 뭔가요?",
    answer:
      "스코프는 식별자(변수, 함수, 클래스 등)가 유효한 범위를 말합니다. 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙이기도 합니다. 스코프는 계층적으로 연결되어 스코프 체인을 형성하며, 변수를 참조할 때 현재 스코프에서 상위 스코프 방향으로 이동하며 검색합니다.",
  },
  {
    id: 233,
    category: "JavaScript",
    question: "스코프에는 어떤 종류가 있죠?",
    answer:
      "스코프는 전역 스코프와 지역 스코프로 나뉩니다. 전역 스코프는 코드의 가장 바깥 영역으로 어디서든 참조할 수 있고, 지역 스코프는 함수 몸체 내부를 말합니다. 또한 var는 함수 레벨 스코프만 인정하고, let과 const는 블록 레벨 스코프를 가져 if, for, while 등의 코드 블록 내에서 유효합니다.",
  },
  {
    id: 234,
    category: "JavaScript",
    question: "렉시컬 스코프를 아나요?",
    answer:
      "렉시컬 스코프(정적 스코프)는 함수를 어디서 호출했는지가 아니라 어디서 정의했는지에 따라 상위 스코프가 결정되는 방식입니다. 자바스크립트는 렉시컬 스코프를 따르므로, 함수의 상위 스코프는 함수가 정의된 위치에 의해 정적으로 결정됩니다. 이 특성은 클로저의 핵심 개념이기도 합니다.",
  },
  {
    id: 235,
    category: "JavaScript",
    question: "전역 변수로 변수를 선언하면 생기는 문제점은?",
    answer:
      "전역 변수는 어디서든 참조 가능하여 의도치 않게 값이 변경될 위험이 있고, 생명 주기가 길어 메모리 리소스를 오래 소비합니다. 스코프 체인의 종점에 위치하여 변수 검색 속도가 느리고, 다른 파일의 전역 변수와 이름이 충돌할 수 있습니다. 이를 방지하기 위해 즉시 실행 함수, 모듈 패턴, ES6 모듈 등을 활용하는 것이 좋습니다.",
  },
  {
    id: 236,
    category: "JavaScript",
    question: "생성자 함수가 뭔가요?",
    answer:
      "생성자 함수는 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수입니다. 일반 함수와 동일한 방식으로 정의하지만, 관례적으로 파스칼 케이스(첫 글자 대문자)로 이름을 짓습니다. 생성자 함수 내부에서 this는 새로 생성될 인스턴스를 가리키며, 동일한 구조의 객체를 여러 개 효율적으로 생성할 수 있습니다.",
  },
  {
    id: 237,
    category: "JavaScript",
    question: "객체 리터럴로 만들 때와 생성자 함수의 차이는?",
    answer:
      "객체 리터럴은 단일 객체를 간편하게 생성할 때 유용하지만, 동일한 구조의 객체를 여러 개 만들면 매번 같은 프로퍼티를 기술해야 하므로 비효율적입니다. 생성자 함수는 프로퍼티 구조가 동일한 객체를 템플릿처럼 반복 생성할 수 있어 코드 재사용성이 높습니다. 또한 생성자 함수로 만든 인스턴스는 prototype을 통해 메서드를 공유할 수 있어 메모리 효율적입니다.",
  },
  {
    id: 238,
    category: "JavaScript",
    question: "생성자 함수가 객체(인스턴스)를 생성하는 과정은?",
    answer:
      "new 연산자로 생성자 함수를 호출하면, 먼저 빈 객체가 생성되고 this에 바인딩됩니다. 그 다음 생성자 함수 내부의 코드가 실행되어 this에 프로퍼티와 메서드를 추가합니다. 마지막으로 생성자 함수가 명시적으로 다른 객체를 반환하지 않으면, 완성된 this(인스턴스)가 암묵적으로 반환됩니다.",
  },
  {
    id: 239,
    category: "JavaScript",
    question: "일급 객체가 뭔가요?",
    answer:
      "일급 객체란 변수에 할당할 수 있고, 함수의 인수로 전달할 수 있으며, 함수의 반환값으로 사용할 수 있는 객체를 말합니다. 또한 런타임에 생성이 가능하고, 무명 리터럴로 생성할 수 있어야 합니다. 자바스크립트의 함수는 이 모든 조건을 충족하므로 일급 객체에 해당합니다.",
  },
  {
    id: 240,
    category: "JavaScript",
    question: "함수가 일급 객체라면, 일급 객체로 뭘 할 수 있나요?",
    answer:
      "함수를 변수에 저장하거나 데이터 구조(배열, 객체)에 담을 수 있고, 다른 함수의 인수로 전달하여 콜백 패턴을 구현할 수 있습니다. 함수에서 함수를 반환하여 클로저를 만들거나, 고차 함수를 구성할 수 있습니다. 이를 통해 함수형 프로그래밍 패턴, 커링, 데코레이터 패턴 등 다양한 프로그래밍 기법을 활용할 수 있습니다.",
  },
  {
    id: 241,
    category: "JavaScript",
    question: "함수형 프로그래밍이 뭔가요?",
    answer:
      "함수형 프로그래밍은 순수 함수와 보조 함수의 조합으로 외부 상태를 변경하는 부수 효과를 최소화하여 불변성을 지향하는 프로그래밍 패러다임입니다. 조건문이나 반복문 대신 고차 함수(map, filter, reduce 등)를 활용하여 선언적으로 코드를 작성합니다. 코드의 예측 가능성을 높이고, 테스트와 디버깅을 용이하게 만드는 장점이 있습니다.",
  },
  {
    id: 242,
    category: "JavaScript",
    question: "순수 함수가 뭔가요?",
    answer:
      "순수 함수는 동일한 인수에 대해 항상 동일한 결과를 반환하고, 외부 상태를 변경하지 않는(부수 효과가 없는) 함수입니다. 함수의 실행이 외부 변수나 상태에 의존하지 않으며, 외부 상태를 수정하지도 않습니다. 이러한 특성 덕분에 코드의 예측 가능성이 높아지고 테스트가 쉬워집니다.",
  },
  {
    id: 243,
    category: "JavaScript",
    question: "Map과 Set에 대해 설명해주세요",
    answer:
      "Map은 키-값 쌍으로 이루어진 컬렉션으로, 객체와 달리 모든 타입의 값을 키로 사용할 수 있고 삽입 순서가 보장됩니다. Set은 중복되지 않는 유일한 값들의 컬렉션으로, 배열의 중복 요소를 제거할 때 유용합니다. 두 자료구조 모두 이터러블이며 forEach, for...of 등으로 순회할 수 있고, size 프로퍼티로 요소의 개수를 확인할 수 있습니다.",
  },
  {
    id: 244,
    category: "JavaScript",
    question: "객체지향 프로그래밍은 무엇을 의미하나요?",
    answer:
      "객체지향 프로그래밍(OOP)은 프로그램을 독립적인 객체의 집합으로 구성하여, 객체 간의 상호작용으로 프로그램을 설계하는 패러다임입니다. 실세계의 사물이나 개념을 속성(프로퍼티)과 행위(메서드)를 가진 객체로 모델링합니다. 코드의 재사용성, 유지보수성, 확장성을 높이는 것이 주요 목적입니다.",
  },
  {
    id: 245,
    category: "JavaScript",
    question: "객체지향 프로그래밍의 특징은?",
    answer:
      "객체지향 프로그래밍의 4가지 핵심 특징은 캡슐화, 상속, 다형성, 추상화입니다. 캡슐화는 데이터와 메서드를 하나로 묶고 외부 접근을 제어하며, 상속은 기존 객체의 속성과 메서드를 물려받아 재사용합니다. 다형성은 같은 인터페이스로 다양한 동작을 구현하는 것이고, 추상화는 복잡한 내부 구현을 숨기고 필요한 부분만 노출하는 것입니다.",
  },
  {
    id: 246,
    category: "JavaScript",
    question: "자바스크립트는 객체지향 프로그래밍 언어인가요?",
    answer:
      "자바스크립트는 프로토타입 기반의 객체지향 프로그래밍을 지원하는 멀티 패러다임 언어입니다. 클래스 기반 언어(Java, C++)와 달리 프로토타입 체인을 통해 상속을 구현하며, ES6부터는 class 문법을 제공하지만 이는 프로토타입의 문법적 설탕(syntactic sugar)입니다. 객체지향뿐만 아니라 함수형 프로그래밍, 명령형 프로그래밍도 지원합니다.",
  },
  {
    id: 247,
    category: "JavaScript",
    question: "프로토타입이 뭔가요?",
    answer:
      "프로토타입은 자바스크립트에서 객체 간 상속을 구현하기 위한 메커니즘입니다. 모든 객체는 [[Prototype]] 내부 슬롯을 통해 자신의 프로토타입에 대한 참조를 가지며, __proto__ 접근자 프로퍼티로 접근할 수 있습니다. 객체의 프로퍼티에 접근할 때 해당 프로퍼티가 없으면 프로토타입 체인을 따라 상위 프로토타입에서 검색하여 상속과 메서드 공유를 가능하게 합니다.",
  },
  {
    id: 248,
    category: "JavaScript",
    question: "빌트인 객체가 뭔가요?",
    answer:
      "빌트인 객체는 자바스크립트 엔진에 기본적으로 내장되어 있는 객체로, 별도의 선언 없이 전역에서 사용할 수 있습니다. Object, String, Number, Boolean, Array, Function, Date, Math, RegExp, Promise, Map, Set 등이 표준 빌트인 객체에 해당합니다. 이들은 프로토타입 메서드와 정적 메서드를 제공하여 자바스크립트 프로그래밍에 필수적인 기능을 지원합니다.",
  },
  {
    id: 249,
    category: "JavaScript",
    question: "래퍼 객체에 대해서 알고 있나요?",
    answer:
      "래퍼 객체는 원시 타입(string, number, boolean)의 값에 대해 마치 객체처럼 마침표 표기법으로 접근할 때, 자바스크립트 엔진이 일시적으로 생성하는 임시 객체입니다. 예를 들어 'hello'.length에 접근하면 문자열을 String 래퍼 객체로 감싸서 프로퍼티에 접근한 뒤, 처리가 끝나면 래퍼 객체를 버리고 다시 원시값으로 되돌립니다. 이 때문에 원시 타입도 빌트인 객체의 프로토타입 메서드를 사용할 수 있습니다.",
  },
  {
    id: 250,
    category: "JavaScript",
    question: "this가 뭔가요?",
    answer:
      "this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수입니다. this를 통해 자신이 속한 객체나 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있습니다. 자바스크립트에서 this는 함수가 호출되는 방식에 따라 동적으로 결정되는 것이 특징입니다.",
  },
  {
    id: 251,
    category: "JavaScript",
    question: "this 바인딩이란?",
    answer:
      "this 바인딩은 this가 가리킬 객체를 연결하는 것을 말합니다. 자바스크립트에서 this 바인딩은 함수 호출 시점에 동적으로 결정됩니다. 일반 함수 호출에서는 전역 객체, 메서드 호출에서는 호출한 객체, 생성자 함수에서는 생성될 인스턴스, call/apply/bind에서는 명시적으로 지정한 객체에 바인딩됩니다.",
  },
  {
    id: 252,
    category: "JavaScript",
    question:
      "this는 동적으로 바인딩이 된다고 하는데 바인딩되는 객체가 어떻게 다르나요?",
    answer:
      "일반 함수로 호출하면 this는 전역 객체(window 또는 global)에 바인딩되고, strict 모드에서는 undefined입니다. 메서드로 호출하면 호출한 객체에, 생성자 함수로 호출하면 새로 생성되는 인스턴스에 바인딩됩니다. call, apply, bind 메서드를 사용하면 this를 명시적으로 지정할 수 있고, 화살표 함수는 자체 this가 없어 상위 스코프의 this를 그대로 사용합니다.",
  },
  {
    id: 253,
    category: "JavaScript",
    question: "실행 컨텍스트에 대해 말해보세요",
    answer:
      "실행 컨텍스트는 소스코드를 실행하는 데 필요한 환경 정보를 모아놓은 객체로, 코드의 실행 순서와 스코프를 관리합니다. 전역 코드, 함수 코드, eval 코드, 모듈 코드 실행 시 생성되며 콜 스택에 쌓여 관리됩니다. 내부에는 변수, 함수 선언 등을 관리하는 렉시컬 환경(Lexical Environment)과 this 바인딩 정보 등이 포함되어 있습니다.",
  },
  {
    id: 254,
    category: "JavaScript",
    question: "클로저에 대해서 아나요?",
    answer:
      "클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합으로, 외부 함수의 실행이 끝나도 내부 함수가 외부 함수의 변수에 접근할 수 있는 현상입니다. 내부 함수가 외부 함수의 변수를 참조하고 있으면, 외부 함수의 실행 컨텍스트가 사라져도 해당 변수가 메모리에서 해제되지 않습니다. 이는 자바스크립트가 렉시컬 스코프를 따르기 때문에 가능합니다.",
  },
  {
    id: 255,
    category: "JavaScript",
    question: "클로저를 사용하면 뭐가 좋죠?",
    answer:
      "클로저를 사용하면 상태를 안전하게 은닉(information hiding)하고, 특정 함수에게만 상태 변경을 허용할 수 있습니다. 전역 변수 사용을 줄이고, 데이터 프라이버시를 구현하며, 함수 팩토리나 모듈 패턴을 만들 수 있습니다. 또한 콜백 함수나 이벤트 핸들러에서 특정 상태를 기억하는 데 유용하게 활용됩니다.",
  },
  {
    id: 256,
    category: "JavaScript",
    question: "클로저를 어떻게 생성하나요?",
    answer:
      "클로저는 외부 함수 안에 내부 함수를 정의하고, 내부 함수가 외부 함수의 변수를 참조하며, 내부 함수를 외부로 반환할 때 생성됩니다. 예를 들어, function outer() { let count = 0; return function() { return ++count; }; }처럼 작성하면, 반환된 함수는 count 변수에 계속 접근할 수 있는 클로저가 됩니다. 콜백 함수나 이벤트 핸들러로 전달되는 함수도 외부 변수를 참조하면 클로저를 형성합니다.",
  },
  {
    id: 257,
    category: "JavaScript",
    question:
      "자바스크립트에서 클래스가 생기기 전에는 어떤 방식으로 객체지향 패턴을 구현했나요?",
    answer:
      "ES6 이전에는 생성자 함수와 프로토타입을 조합하여 객체지향 패턴을 구현했습니다. 생성자 함수로 인스턴스를 생성하고, prototype 객체에 메서드를 정의하여 상속을 구현했습니다. 상속은 Object.create()나 프로토타입 체인을 수동으로 연결하는 방식으로 처리했으며, 모듈 패턴과 즉시 실행 함수를 활용하여 캡슐화를 구현했습니다.",
  },
  {
    id: 258,
    category: "JavaScript",
    question: "생성자 함수와 클래스는 어떤 차이가 있나요?",
    answer:
      "클래스는 new 연산자 없이 호출하면 에러가 발생하지만, 생성자 함수는 일반 함수로 호출됩니다. 클래스는 상속을 지원하는 extends와 super 키워드를 제공하며, 클래스 내부 코드는 암묵적으로 strict mode가 적용됩니다. 또한 클래스는 호이스팅이 발생하지 않는 것처럼 동작하며, 클래스의 모든 메서드는 열거 불가능(non-enumerable)합니다.",
  },
  {
    id: 259,
    category: "JavaScript",
    question: "클래스의 상속에 대해 설명해주세요",
    answer:
      "클래스 상속은 extends 키워드를 사용하여 부모 클래스의 속성과 메서드를 자식 클래스가 물려받는 것입니다. 자식 클래스에서 super()를 호출하여 부모 클래스의 constructor를 실행하고, super.method()로 부모의 메서드를 호출할 수 있습니다. 자식 클래스에서 같은 이름의 메서드를 재정의(오버라이딩)하면 부모 메서드 대신 자식 메서드가 호출되어 다형성을 구현할 수 있습니다.",
  },
  {
    id: 260,
    category: "JavaScript",
    question: "브라우저의 렌더링 과정에 대해 설명해보세요",
    answer:
      "브라우저는 먼저 HTML을 파싱하여 DOM 트리를, CSS를 파싱하여 CSSOM 트리를 생성합니다. DOM과 CSSOM을 결합하여 렌더 트리를 만들고, 레이아웃(Layout) 단계에서 각 요소의 위치와 크기를 계산합니다. 마지막으로 페인트(Paint) 단계에서 화면에 실제 픽셀을 그리고, 필요시 합성(Composite) 과정을 거쳐 레이어를 합칩니다.",
  },
  {
    id: 261,
    category: "JavaScript",
    question: "브라우저의 렌더링 과정에 자바스크립트는 어떻게 동작하나요?",
    answer:
      "HTML 파싱 중 script 태그를 만나면 파싱을 중단하고 자바스크립트 엔진에 제어권을 넘깁니다. 자바스크립트 엔진은 코드를 파싱하여 AST(추상 구문 트리)를 생성하고, 바이트코드로 변환하여 실행합니다. 자바스크립트 실행이 완료되면 다시 HTML 파싱이 재개되므로, 스크립트의 위치와 async/defer 속성이 렌더링 성능에 영향을 줍니다.",
  },
  {
    id: 262,
    category: "JavaScript",
    question: "script 태그를 body 태그 밑에 둬야하는 이유가 있을까요?",
    answer:
      "script 태그를 body 하단에 두면 HTML 파싱이 완료된 후 스크립트가 실행되므로, DOM이 완성되기 전에 DOM을 조작하려는 에러를 방지할 수 있습니다. 또한 HTML 파싱이 스크립트에 의해 블로킹되지 않아 페이지가 사용자에게 더 빠르게 표시됩니다. 대안으로 script 태그에 defer 속성을 사용하면 head에 두어도 HTML 파싱 완료 후 실행되게 할 수 있습니다.",
  },
  {
    id: 263,
    category: "JavaScript",
    question: "DOM이 뭔가요?",
    answer:
      "DOM(Document Object Model)은 HTML 문서의 구조화된 표현으로, 브라우저가 HTML을 파싱하여 생성하는 트리 구조의 객체 모델입니다. 자바스크립트를 통해 DOM에 접근하여 문서의 구조, 스타일, 내용을 동적으로 변경할 수 있습니다. DOM은 W3C 표준으로 프로그래밍 언어가 문서에 접근할 수 있는 API를 제공합니다.",
  },
  {
    id: 264,
    category: "JavaScript",
    question: "DOM을 구성하는 건 뭐가 있나요?",
    answer:
      "DOM은 노드(Node)로 구성되며, 크게 문서 노드(Document), 요소 노드(Element), 어트리뷰트 노드(Attr), 텍스트 노드(Text)로 나뉩니다. 문서 노드는 DOM 트리의 최상위 노드이고, 요소 노드는 HTML 태그를 나타내며, 텍스트 노드는 태그 내의 텍스트를 나타냅니다. 이 노드들이 부모-자식, 형제 관계로 연결되어 트리 구조를 이룹니다.",
  },
  {
    id: 265,
    category: "JavaScript",
    question: "이벤트 전파(propagation)에 대해서 알고 있나요?",
    answer:
      "이벤트 전파는 DOM 요소에서 이벤트가 발생했을 때 이벤트가 전달되는 흐름입니다. 캡처링 단계에서 이벤트가 window에서 타겟 요소까지 하위로 전파되고, 타겟 단계에서 이벤트가 타겟에 도달하며, 버블링 단계에서 타겟에서 window까지 상위로 전파됩니다. 대부분의 이벤트는 버블링되며, event.stopPropagation()으로 전파를 중단할 수 있습니다.",
  },
  {
    id: 266,
    category: "JavaScript",
    question: "이벤트 위임(delegation)에 대해서 알고있나요?",
    answer:
      "이벤트 위임은 여러 하위 요소에 개별적으로 이벤트 핸들러를 등록하는 대신, 상위 요소 하나에 이벤트 핸들러를 등록하여 하위 요소의 이벤트를 처리하는 패턴입니다. 이벤트 버블링을 활용하며, event.target을 통해 실제 이벤트가 발생한 요소를 식별합니다. 동적으로 추가되는 요소에도 자동으로 이벤트 처리가 적용되고, 메모리 사용을 줄이며 성능을 향상시킵니다.",
  },
  {
    id: 267,
    category: "JavaScript",
    question: "디바운스에 대해서 알고 있나요?",
    answer:
      "디바운스는 연속적으로 발생하는 이벤트에서 마지막 이벤트가 발생한 후 일정 시간이 지나면 한 번만 실행하는 기법입니다. 짧은 시간 간격으로 이벤트가 연속 발생하면 이전 타이머를 취소하고 새 타이머를 설정합니다. 주로 검색 입력 자동완성, 창 크기 조절(resize) 이벤트 등에서 불필요한 함수 호출을 줄이기 위해 사용됩니다.",
  },
  {
    id: 268,
    category: "JavaScript",
    question: "쓰로틀에 대해서 알고 있나요?",
    answer:
      "쓰로틀은 일정 시간 간격 동안 이벤트가 아무리 많이 발생해도 최대 한 번만 함수를 실행하도록 제한하는 기법입니다. 디바운스와 달리 일정 주기로 반드시 한 번은 실행이 보장됩니다. 주로 스크롤 이벤트, 무한 스크롤 구현, 드래그 이벤트 등 빈번하게 발생하는 이벤트의 성능을 최적화할 때 사용합니다.",
  },
  {
    id: 269,
    category: "JavaScript",
    question: "동기와 비동기의 차이점은?",
    answer:
      "동기(Synchronous)는 현재 실행 중인 작업이 완료될 때까지 다음 작업이 대기하는 방식으로, 코드가 순서대로 실행됩니다. 비동기(Asynchronous)는 현재 작업의 완료를 기다리지 않고 다음 작업을 바로 실행하는 방식으로, 작업이 완료되면 콜백 등으로 결과를 전달받습니다. 자바스크립트는 싱글 스레드이지만 이벤트 루프를 통해 비동기 처리를 구현하여 네트워크 요청, 타이머 등의 작업을 효율적으로 처리합니다.",
  },
  {
    id: 270,
    category: "JavaScript",
    question: "이벤트 루프와 태스크 큐에 대해서 알고 있나요?",
    answer:
      "이벤트 루프는 콜 스택이 비어있는지 확인하고, 비어있으면 태스크 큐에서 대기 중인 콜백 함수를 콜 스택으로 이동시키는 메커니즘입니다. 태스크 큐(매크로태스크 큐)에는 setTimeout, setInterval, I/O 콜백 등이 담깁니다. 이를 통해 싱글 스레드인 자바스크립트가 비동기 작업을 처리할 수 있으며, Web API가 비동기 작업을 수행한 후 완료된 콜백을 태스크 큐에 넣는 방식으로 동작합니다.",
  },
  {
    id: 271,
    category: "JavaScript",
    question: "마이크로태스크 큐에 대해서 알고 있나요?",
    answer:
      "마이크로태스크 큐는 태스크 큐보다 우선순위가 높은 별도의 큐로, Promise의 then/catch/finally 핸들러, MutationObserver 콜백, queueMicrotask 등이 담깁니다. 이벤트 루프는 콜 스택이 비면 마이크로태스크 큐를 먼저 비운 후에 태스크 큐의 콜백을 실행합니다. 따라서 Promise 콜백은 setTimeout 콜백보다 항상 먼저 실행됩니다.",
  },
  {
    id: 272,
    category: "JavaScript",
    question: "REST API가 뭔가요?",
    answer:
      "REST API는 REST(Representational State Transfer) 아키텍처 스타일을 준수하는 API입니다. HTTP 프로토콜을 기반으로 자원(Resource)을 URI로 식별하고, HTTP 메서드(GET, POST, PUT, DELETE 등)로 자원에 대한 행위를 정의합니다. 클라이언트-서버 구조, 무상태(Stateless), 캐시 가능, 계층화 시스템 등의 원칙을 따릅니다.",
  },
  {
    id: 273,
    category: "JavaScript",
    question: "REST API를 설계하는데 중요한 것은?",
    answer:
      "URI는 리소스를 명확하게 표현해야 하며, 동사보다 명사를 사용하는 것이 좋습니다(예: /users, /posts). 행위는 URI가 아닌 HTTP 메서드로 표현하고, 슬래시(/)는 계층 관계를 나타냅니다. 응답에는 적절한 HTTP 상태 코드를 사용하고, 일관된 데이터 형식(주로 JSON)으로 응답하며, 버전 관리를 통해 API의 하위 호환성을 유지하는 것이 중요합니다.",
  },
  {
    id: 274,
    category: "JavaScript",
    question: "HTTP 요청 메서드에 대해서 설명해주세요",
    answer:
      "GET은 리소스를 조회할 때, POST는 새로운 리소스를 생성할 때, PUT은 리소스 전체를 교체할 때, PATCH는 리소스의 일부를 수정할 때, DELETE는 리소스를 삭제할 때 사용합니다. GET과 DELETE는 요청 본문(body)이 없고, POST, PUT, PATCH는 요청 본문을 가집니다. GET은 멱등성과 안전성을 보장하며, PUT과 DELETE는 멱등성을 보장하지만 안전하지 않습니다.",
  },
  {
    id: 275,
    category: "JavaScript",
    question: "콜백이란?",
    answer:
      "콜백은 다른 함수에 인수로 전달되어 특정 시점에 호출되는 함수를 말합니다. 동기 콜백은 즉시 실행되고(예: forEach의 콜백), 비동기 콜백은 특정 이벤트나 작업 완료 후에 실행됩니다(예: setTimeout의 콜백). 비동기 콜백이 중첩되면 '콜백 헬(Callback Hell)'이 발생하여 코드의 가독성과 유지보수성이 떨어지는데, 이를 해결하기 위해 프로미스나 async/await이 도입되었습니다.",
  },
  {
    id: 276,
    category: "JavaScript",
    question: "프로미스가 뭔가요?",
    answer:
      "프로미스(Promise)는 비동기 작업의 최종 완료 또는 실패를 나타내는 객체로, ES6에서 도입되었습니다. 콜백 헬을 해결하기 위한 패턴으로, then, catch, finally 메서드를 통해 비동기 처리 결과를 후속 처리합니다. then 메서드가 프로미스를 반환하므로 체이닝이 가능하여, 비동기 처리를 순차적이고 가독성 높게 작성할 수 있습니다.",
  },
  {
    id: 277,
    category: "JavaScript",
    question: "프로미스의 상태를 나타내는 것은?",
    answer:
      "프로미스는 pending(대기), fulfilled(이행), rejected(거부) 세 가지 상태를 가집니다. 처음 생성되면 pending 상태이고, 비동기 작업이 성공하면 resolve가 호출되어 fulfilled 상태가 되며, 실패하면 reject가 호출되어 rejected 상태가 됩니다. fulfilled와 rejected를 합쳐 settled(처리됨)라 하며, 한번 settled 상태가 되면 다시 변경되지 않습니다.",
  },
  {
    id: 278,
    category: "JavaScript",
    question: "제너레이터란 뭔가요?",
    answer:
      "제너레이터는 function* 키워드로 선언하며, yield 키워드를 사용하여 함수 실행을 중간에 멈추고 재개할 수 있는 특수한 함수입니다. 호출하면 제너레이터 객체(이터러블이자 이터레이터)를 반환하며, next() 메서드로 yield 지점까지 실행하고 값을 주고받을 수 있습니다. 비동기 처리를 동기처럼 구현하거나 무한 시퀀스를 지연 평가할 때 유용하며, async/await의 기반이 됩니다.",
  },
  {
    id: 279,
    category: "JavaScript",
    question: "async/await가 뭔가요? Promise와의 차이는?",
    answer:
      "async/await는 ES8에서 도입된 비동기 처리 문법으로, 프로미스를 더 직관적으로 사용할 수 있게 해줍니다. async 함수는 항상 프로미스를 반환하고, await는 프로미스가 settled될 때까지 함수 실행을 일시 중지합니다. 프로미스의 then 체이닝보다 동기 코드처럼 읽기 쉬우며, try/catch로 에러를 처리할 수 있어 가독성과 에러 처리가 더 직관적입니다.",
  },
  {
    id: 280,
    category: "JavaScript",
    question: "에러처리를 왜 해야 하나요?",
    answer:
      "에러 처리를 하지 않으면 예외 발생 시 프로그램이 강제로 종료되어 사용자 경험이 크게 저하됩니다. 적절한 에러 처리를 통해 프로그램의 안정성을 높이고, 사용자에게 의미 있는 피드백을 제공할 수 있습니다. 또한 에러의 원인을 로깅하여 디버깅을 쉽게 만들고, 예외 상황에서도 프로그램이 정상적으로 동작하도록 보장할 수 있습니다.",
  },
  {
    id: 281,
    category: "JavaScript",
    question: "자바스크립트에서 에러를 처리하는 방법은?",
    answer:
      "try...catch...finally 문을 사용하여 동기 코드의 에러를 처리할 수 있으며, try 블록에서 에러가 발생하면 catch 블록이 실행되고 finally는 항상 실행됩니다. 프로미스의 경우 .catch() 메서드나 async/await의 try...catch로 에러를 처리합니다. throw 문으로 사용자 정의 에러를 발생시킬 수 있고, Error 객체를 상속하여 커스텀 에러 클래스를 만들 수도 있습니다.",
  },
  {
    id: 282,
    category: "JavaScript",
    question: "모듈이 뭔가요?",
    answer:
      "모듈은 애플리케이션을 구성하는 개별적인 코드 단위로, 관련된 변수, 함수, 클래스 등을 하나의 파일로 묶은 것입니다. 모듈은 자체적인 스코프를 가져 전역 스코프를 오염시키지 않으며, export로 모듈 외부에 공개하고 import로 다른 모듈을 가져옵니다. ES6에서 import/export 문법이 표준화되었으며, 코드의 재사용성, 유지보수성, 네임스페이스 관리에 도움을 줍니다.",
  },
  {
    id: 283,
    category: "JavaScript",
    question: "자바스크립트의 가비지 컬렉션에 대해 알고 있나요?",
    answer:
      "가비지 컬렉션은 자바스크립트 엔진이 더 이상 참조되지 않는 메모리를 자동으로 해제하는 메모리 관리 메커니즘입니다. 주로 도달 가능성(reachability) 알고리즘을 사용하며, 루트(전역 객체 등)에서 도달할 수 없는 객체를 가비지로 판단하여 제거합니다. 개발자가 명시적으로 메모리를 해제하지 않아도 되지만, 순환 참조나 불필요한 참조를 유지하면 메모리 누수가 발생할 수 있으므로 주의가 필요합니다.",
  },
];
